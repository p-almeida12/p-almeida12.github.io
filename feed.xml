<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://p-almeida12.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://p-almeida12.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-04T18:12:38+00:00</updated><id>https://p-almeida12.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Event-Driven Microservices - Kafka and RabbitMQ</title><link href="https://p-almeida12.github.io/blog/2024/event-driven-microservices/" rel="alternate" type="text/html" title="Event-Driven Microservices - Kafka and RabbitMQ"/><published>2024-12-01T14:59:00+00:00</published><updated>2024-12-01T14:59:00+00:00</updated><id>https://p-almeida12.github.io/blog/2024/event-driven-microservices</id><content type="html" xml:base="https://p-almeida12.github.io/blog/2024/event-driven-microservices/"><![CDATA[<p><span style="margin-left: 10px;"></span> How can we achieve seamless communication in microservices? Event-driven architecture is the key to making that happen, by connecting services through events, systems can handle complex processes with ease, scale efficiently, and respond to changes in real time. Apache Kafka and RabbitMQ are tools commonly used for this purpose, both offer powerful features but serving different purposes. Choosing the right one is important, but for that we have to understand how both tools work and where they shine, that’s why I’m writing this post, to get a better understanding of these giants in the IT world.</p> <h1 id="what-is-event-driven-architecture">What is Event-Driven Architecture?</h1> <p><span style="margin-left: 10px;"></span> Event-driven architecture (EDA) is a software design pattern where systems revolve around the production, detection, and reaction to events. An event represents any significant change in the state of a system, such as a user placing an order or a payment being processed. These events are transmitted to other parts of the system asynchronously, enabling various components to respond in near real-time without direct dependencies.</p> <p><span style="margin-left: 10px;"></span> EDA typically includes three core components:</p> <ul> <li>Event Producers: Systems or applications that generate events (e.g., a user action or a system update).</li> <li>Event Routers: Tools like message brokers (e.g., Kafka, RabbitMQ) that transport these events to the right consumers.</li> <li>Event Consumers: Services or systems that react to these events by performing tasks, such as sending notifications or updating records.</li> </ul> <p><span style="margin-left: 10px;"></span> This decoupled structure ensures that event producers don’t need to know who consumes their events, fostering a highly modular system architecture (Martin Fowler, Event-Driven Architecture).</p> <h2 id="the-role-of-event-driven-architecture-in-microservices">The Role of Event-Driven Architecture in Microservices</h2> <p><span style="margin-left: 10px;"></span> EDA is particularly valuable in microservices because it allows individual services to communicate without being tightly coupled. Instead of directly invoking each other’s APIs, services emit events representing actions. Other services subscribe to these events and respond as needed. This indirect communication method enhances system flexibility and simplifies service management.</p> <p><span style="margin-left: 10px;"></span> For instance, consider an e-commerce system:</p> <ul> <li>The order service emits an “Order Placed” event when a user completes a purchase.</li> <li>The inventory service listens for this event to adjust stock levels.</li> <li>Simultaneously, the notification service sends a confirmation email, while the shipping service begins preparing for delivery.</li> </ul> <p><span style="margin-left: 10px;"></span> This design allows these services to function independently while still coordinating efficiently, as proposed by Sam Newman in Building Microservices. This is what decoupling is all about, services can evolve independently, scale, etc…</p> <h2 id="benefits-of-event-driven-architecture">Benefits of Event-Driven Architecture</h2> <ul> <li><strong>Decoupling</strong>: services remain independent, reducing dependencies. For example, a producer like an order service doesn’t need to know which services consume its events, as discussed in Martin Fowler’s article on EDA.</li> <li><strong>Scalability</strong>: events are processed asynchronously, services can scale independently based on demand. Apache Kafka’s distributed architecture is explicitly designed to handle millions of events per second.</li> <li><strong>Responsiveness</strong>: systems can react to events in real time. For instance, fraud detection systems can immediately analyze suspicious activity by consuming events from a payment service.</li> <li><strong>Resilience</strong>: Failures in one part of the system don’t cascade. Events can be queued and retried later, ensuring no critical data is lost. RabbitMQ supports this with its dead-letter queues and acknowledgment mechanisms (ack).</li> <li><strong>Extensibility</strong>: New services can be added simply by subscribing to existing events, making it easier to evolve the system over time.</li> <li><strong>Real-Time Data Processing</strong>: Tools like Kafka allow for continuous data streaming, essential for real-time analytics and machine learning workflows. For example, LinkedIn uses Kafka for activity tracking and user recommendations.</li> </ul> <h1 id="overview-of-kafka-and-rabbitmq">Overview of Kafka and RabbitMQ</h1> <h2 id="apache-kafka">Apache Kafka</h2> <p><span style="margin-left: 10px;"></span> Kafka follows a distributed, publish-subscribe architecture with a few key components:</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/kafka_architecture.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 4 - Apache Kafka Architecture </div> <h3 id="producer">Producer</h3> <p><span style="margin-left: 10px;"></span> Any application or service that sends events (messages) to Kafka topics. A kafka producer holds a buffer of unsent records per partition and sends the records to the cluster using an internal batch.size property. In most of the cases the default size could be good enough, but you may want to play around with this value to get a better throughput by increasing the batching. But keep in mind that if the batch size is too big the memory will be wasted since the part of the memory that is allocated for batching will not be used. This happens because the data will be sent before the batch size limit hits. Using a larger batch size makes compression more efficient.</p> <p><span style="margin-left: 10px;"></span> Under heavy loads, batching will probably be in place, however, in light loads data may not be batched until the batch size limit hits, in that case increasing the linger.ms can increase the throughput by increasing batching with fewer requests and with an increased latency on producer send. By default linger.ms is 0, which means no delay. As mentioned previously in Kafka there are multiple broker nodes that holds the same data to enable resilience and availability. By default the producer will wait all replica nodes to return the result because the default value for acknowledgement is all, by setting ack to 1 only the broker that sent the request will send confirmation instead of waiting all in-sync replicas.</p> <p><span style="margin-left: 10px;"></span> Producers can also compress the data before sending it to the broker, this can be done by setting the compression.type property. The compression is done by batch and improves with larger batch sizes. By using compressed data, you can send more data at once through the network and increase the throughput. End to end compression is also possible, this way compression only happens once and is reused by the producer and consumer (better for performance).</p> <h3 id="broker">Broker</h3> <p><span style="margin-left: 10px;"></span> A Kafka Broker is a server (or node) in a Kafka cluster responsible for receiving, storing, and forwarding messages (or events) to consumers. It is a fundamental component of Kafka’s distributed architecture. A Kafka cluster consists of one or more brokers, where each broker is a part of a larger system that stores the actual data (i.e., the events/messages). Each broker is responsible for managing a set of partitions for one or more topics.</p> <p><span style="margin-left: 10px;"></span> Kafka brokers store messages in a distributed manner, partitioning the data across multiple disks for better performance, scalability, and fault tolerance. Kafka brokers receive messages from producers, append them to the appropriate partitions, and handle message delivery to consumers. Brokers handle the replication of data to ensure fault tolerance. Each partition’s data is replicated across multiple brokers to ensure that if one broker fails, data remains available from other brokers in the cluster.</p> <p><span style="margin-left: 10px;"></span> Each partition has one leader broker responsible for handling all read and write operations for that partition. The leader ensures that data is consistently written to the partition, maintains the order of messages, and manages replication. If a producer wants to send a message to a topic, it sends the message to the leader of the corresponding partition.</p> <p><span style="margin-left: 10px;"></span> Followers are brokers that maintain copies of the partition’s data. These replicas are updated with messages from the leader to ensure fault tolerance. Followers do not handle writes; instead, they replicate data from the leader to maintain synchronization. If a follower is too far behind, it may be temporarily excluded from the replication process.</p> <p><span style="margin-left: 10px;"></span> If a leader broker fails, Kafka automatically promotes one of the followers to become the new leader. This process is known as leader election, which is crucial for maintaining high availability. Kafka uses ZooKeeper (in the traditional setup) or KRaft (in newer versions) for leader election and managing partition metadata.</p> <h3 id="consumer">Consumer:</h3> <p><span style="margin-left: 10px;"></span> The application or service that reads data from Kafka topics. Kafka relies on logs which are known as partitions, the producers write to the end of a specific partition and the consumers read the logs starting from the beginning while holding an offset to keep track. When it is done with the data, the consumer sends a commit request to the broker so that there will be an offset per consumer per partition, to remember the latest record that was read. This way consumer will continue reading new data instead of reading the same data again.</p> <p><span style="margin-left: 10px;"></span> Each consumer belongs to a consumer group and Kafka distributes partitions to consumers based on these consumer groups. Each partition is strictly assigned to a single consumer in a consumer group, therefore it is not possible to assign the same partition to more than one consumer. This is to prevent conflicts with the offset values and make consuming easier. Different consumer groups with different ids can read the same data form the same partition, so kafka allows you to read the same data more than once, but for that you need to create a new consumer group and read the data again. For maximum concurrency, it is wise to set the consumer number as equal to the partition number. If you create more consumers than partition numbers, after assigning each partition to a consumer, some consumers will be idle and will not read any data.</p> <p><span style="margin-left: 10px;"></span> There is a poll time out in Kafka consumer and setting it to a too high value will make the waiting take longer and cause delays in the application. If the poll time out is too low, the consumer will poll more frequently and this will cause more network traffic and can lead to CPU stall. If you have a single consumer with multiple partitions, there will be no concurrent work on multiple partitions by default (multithreading), but we can still use multiple threads while consuming partitions. This should be implemented on the client side.</p> <p><span style="margin-left: 10px;"></span> When it comes to delivery semantics, Kafka provides three options: at most once, at least once, and exactly once. This behavior relies on the consumer strategy and the ack property on the client side. For example, if you commit after processing the data, the commit operation might fail, but you already processed the data, so in the next poll you will read the same data and it will imply at least once behavior. On the other hand, if you commit before processing the data, you might lose the data if the consumer crashes, so it will imply at most once behavior. Exactly once requires to coordinate between producer and consumer, using transactions starting from the producer part. There is a transaction Kafka API which will start the transaction from producer to use the same transaction in the consumer part. Normally auto commit is set to true on the consumer client, so it does a commit after a configured timer and then reset it. But keep in mind that in some scenarios you might still encounter an error while auto commit is set to true, because a failure can always happen. With this being said, you might need to implement some rollback mechanism or use strict exactly once semantic depending on your needs.</p> <h3 id="topic">Topic</h3> <p><span style="margin-left: 10px;"></span> A Topic is a logical channel or category to which Kafka producers send their messages and from which consumers read their messages. Kafka topics are a fundamental abstraction that organizes messages for efficient routing, storage, and consumption. Topics are essentially message queues to which producers publish data and from which consumers pull data.</p> <p><span style="margin-left: 10px;"></span> Topics help categorize messages by their purpose, such as a “user_signup” topic for user registration events or a “payment_processed” topic for payment-related messages. Consumers subscribe to one or more topics and receive messages (events) that are published to those topics. Kafka follows a publish-subscribe model, where producers publish messages to a topic, and consumers subscribe to topics to receive those messages. A topic can have multiple producers and consumers, allowing for a highly scalable and distributed pub-sub system. Kafka topics are stored on disk, and messages are retained in a topic for a configurable retention period (even after they are consumed, unless manually deleted).</p> <h3 id="zookeeper">ZooKeeper</h3> <p><span style="margin-left: 10px;"></span> Apache ZooKeeper is a distributed coordination service that is used by Kafka to manage and maintain the Kafka cluster. It acts as a centralized service for maintaining configuration information, providing synchronization, and ensuring the integrity of the system.</p> <p><span style="margin-left: 10px;"></span> In earlier versions of Kafka, ZooKeeper was an essential component for managing brokers and maintaining Kafka’s distributed system metadata, such as which broker holds which partition and its leadership. Now newer versions of Kafka are transitioning away from ZooKeeper (Kafka KRaft mode), it is still used in many existing Kafka deployments. ZooKeeper ensures that even if one broker goes down, another broker can take over the responsibility of a partition, thanks to its role in maintaining partition leader information.</p> <h3 id="kraft">KRaft</h3> <p><span style="margin-left: 10px;"></span> KRaft (Kafka Raft) is a significant shift in how Apache Kafka manages its cluster metadata and leader election. Traditionally, Kafka used ZooKeeper to manage cluster metadata, including partition leaders, topic configurations, and broker statuses. However, with the introduction of KRaft mode in Kafka, ZooKeeper is no longer required, and Kafka now uses its own internal protocol to manage these responsibilities.</p> <p><span style="margin-left: 10px;"></span> In KRaft mode, Kafka maintains a metadata quorum that is responsible for managing cluster metadata, including topic configurations, partition leadership, and broker statuses. This quorum uses Raft to achieve consensus on metadata changes across all brokers.</p> <p><span style="margin-left: 10px;"></span> The Raft protocol ensures that Kafka’s metadata is consistently replicated across multiple nodes in the cluster. Raft allows Kafka brokers to elect a leader for the metadata quorum, and that leader is responsible for updating metadata and synchronizing changes with follower brokers.</p> <p><span style="margin-left: 10px;"></span> One of the biggest changes with KRaft mode is the removal of ZooKeeper. This drastically simplifies Kafka’s architecture, as Kafka now manages its own leader election and metadata replication without relying on an external service like ZooKeeper. This change reduces operational overhead, makes cluster management more straightforward, and eliminates the complexity of maintaining and configuring ZooKeeper.</p> <p><span style="margin-left: 10px;"></span> Final considerations:</p> <ul> <li><strong>Transition from ZooKeeper</strong>: Migrating from a traditional ZooKeeper-based Kafka setup to KRaft can be a complex process, especially for large and heavily used Kafka clusters. Users must ensure that their applications and systems are compatible with KRaft mode and handle any potential disruptions during the migration.</li> <li><strong>New Features and Stability</strong>: KRaft mode is still being refined, and certain features that were available with ZooKeeper may take time to fully mature in KRaft. For instance, features like multi-cluster replication and some advanced configurations may not be as mature as in Zookeeper.</li> <li><strong>Cluster Scaling</strong>: While KRaft simplifies the Kafka architecture, scaling the cluster (both in terms of adding brokers and handling large amounts of metadata) requires careful planning and monitoring. The Raft protocol can introduce its own set of challenges when scaling up a Kafka cluster, especially as the metadata grows more complex.</li> </ul> <h2 id="rabbitmq">RabbitMQ</h2> <p><span style="margin-left: 10px;"></span> RabbitMQ’s architecture is based on a client-server model and revolves around producers, exchanges, queues, and consumers. These components work together to provide a robust, reliable messaging system.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/rabbitmq_architecture.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 4 - RabbitMQ Architecture </div> <h3 id="producer-1">Producer</h3> <p><span style="margin-left: 10px;"></span> A Producer is any application or service that sends messages to RabbitMQ. Producers do not directly interact with queues; instead, they send messages to an Exchange, which is responsible for routing the message to the appropriate queue or queues. Producers include a routing key with each message. This key acts as a tag used by exchanges to determine where the message should go. Producers specify the exchange name when sending a message.</p> <p><span style="margin-left: 10px;"></span> If no exchange is specified, RabbitMQ uses the default exchange. Producers send messages without waiting for confirmation that a consumer has processed them, ensuring decoupled communication (although it is possible to wait for the response, but breaks the decoupling).</p> <h3 id="exchange">Exchange</h3> <p><span style="margin-left: 10px;"></span> An Exchange is a central routing mechanism in RabbitMQ. It receives messages from producers and determines how to route them to one or more queues based on routing keys and bindings. RabbitMQ supports several types of exchanges, each tailored for specific routing scenarios:</p> <ul> <li><strong>Direct Exchange</strong>: Routes messages to queues based on an exact match between the routing key and the queue’s binding key.</li> <li><strong>Fanout Exchange</strong>: Broadcasts messages to all queues bound to the exchange, ignoring the routing key.</li> <li><strong>Topic Exchange</strong>: Routes messages based on pattern matching of the routing key. Patterns use wildcards: <ul> <li>* matches exactly one word (e.g., log.* matches log.info but not log.error.system).</li> <li># matches zero or more words (e.g., log.# matches log.info and log.error.system).</li> </ul> </li> <li><strong>Headers Exchange</strong>: Routes messages based on custom headers (not the routing key).</li> </ul> <h3 id="queues">Queues</h3> <p><span style="margin-left: 10px;"></span> A Queue is a buffer where messages are stored until they are retrieved by consumers. Queues decouple producers and consumers, ensuring that message delivery is reliable even if the consumer is temporarily unavailable. Some of the features of RabbitMQ queues:</p> <ul> <li><strong>Persistence</strong>: Queues can be configured as durable to be able survive broker restarts. This happens because messages are saved to disk.</li> <li><strong>Message Priority</strong>: Queues can prioritize certain messages to ensure critical tasks are handled first.</li> <li><strong>Message TTL</strong>: If a message is unconsumed, a Time-to-Live (TTL) can be set to discard it after a given period.</li> </ul> <p><span style="margin-left: 10px;"></span> Messages that cannot be routed or are rejected by a consumer can be redirected to a Dead Letter Queue (DLQ) for later inspection or retrying. This is useful for debugging and analyzing failed messages.</p> <h3 id="bindings">Bindings</h3> <p><span style="margin-left: 10px;"></span> A Binding is the relationship between an exchange and a queue. Bindings define the rules that exchanges use to route messages to specific queues. Binding keys act as filters for routing messages. For example, a queue bound to a direct exchange with the binding key “error” will receive only messages with a routing key of error. Multiple Bindings is when a single queue can be bound to an exchange with multiple binding keys. This allows the queue to receive messages matching multiple patterns.</p> <h3 id="consumers">Consumers</h3> <p><span style="margin-left: 10px;"></span> A Consumer is any application or service that retrieves and processes messages from a queue. Consumers are responsible for ensuring message reliability by acknowledging successful processing.</p> <ul> <li><strong>Manual Acknowledgment</strong>: Consumers explicitly acknowledge each message after successful processing. This ensures that messages are not lost if the consumer crashes during processing.</li> <li><strong>Automatic Acknowledgment</strong>: RabbitMQ automatically considers the message acknowledged once it is delivered to the consumer. This is faster but less reliable.</li> </ul> <p><span style="margin-left: 10px;"></span> Consumers can configure a pre-fetch count to limit the number of messages delivered at a time. This prevents the consumer from being overwhelmed and ensures fair distribution in a multi-consumer scenario.</p> <h3 id="broker-1">Broker</h3> <p><span style="margin-left: 10px;"></span> The RabbitMQ broker is the server managing the exchanges, queues, and bindings. It ensures that messages are reliably routed and stored as needed. The broker also handles load balancing and fault tolerance.</p> <h3 id="other-features">Other Features</h3> <p><span style="margin-left: 10px;"></span> RabbitMQ nodes can form clusters, allowing them to share metadata and distribute workloads across multiple machines. While clusters improve load balancing, queues are hosted by a single node unless explicitly mirrored.</p> <p><span style="margin-left: 10px;"></span> To ensure high availability, RabbitMQ supports mirrored queues, replicating data across multiple nodes. If the primary node fails, a replica takes over to avoid service interruptions.</p> <p><span style="margin-left: 10px;"></span> RabbitMQ can shard queues across nodes, distributing the load and preventing bottlenecks in high-throughput systems.</p> <p><span style="margin-left: 10px;"></span> Routing mechanisms like dynamic routing, priority queues and dead-letter exchanges provide flexibility in message handling and delivery.</p> <h2 id="kafka-vs-rabbitmq">Kafka vs. RabbitMQ</h2> <p><span style="margin-left: 10px;"></span> When deciding between Apache Kafka and RabbitMQ for your microservices architecture, it’s crucial to understand their core differences. Below is a comparison based on various aspects like message models, use cases, scalability, durability, and routing.</p> <p><span style="margin-left: 10px;"></span> Kafka is designed as a distributed log system that streams messages in real time. It follows a publish-subscribe model, where producers write messages to topics, and consumers read them independently. Kafka retains messages for a specified duration regardless of consumption, enabling replayability for debugging and analytics. Kafka is ideal for high-throughput, real-time use cases such as:</p> <ul> <li>Event sourcing in microservices.</li> <li>Real-time analytics pipelines.</li> <li>Log aggregation across distributed systems.</li> <li>Use in industries like finance (stock), retail (inventory updates), and for sensor data streaming.</li> </ul> <p><span style="margin-left: 10px;"></span> RabbitMQ operates as a traditional message broker with a focus on message queuing. Producers send messages to an exchange, which routes them to queues based on bindings. Consumers then process messages, and once acknowledged, they are removed from the queue. RabbitMQ prioritizes reliable delivery over retention. Here are some use cases where RabbitMQ is commonly used:</p> <ul> <li>Asynchronous task execution (e.g., sending emails, processing images).</li> <li>Workload balancing across multiple consumers.</li> <li>Systems where message ordering and routing flexibility are critical.</li> </ul> <p><span style="margin-left: 10px;"></span> In terms of scalability and performance, Kafka’s partitioned, distributed architecture makes it highly scalable. Topics are divided into partitions spread across brokers, allowing for parallel processing. It achieves millions of messages per second but requires significant setup and infrastructure. On the other hand, RabbitMQ scales well within a single cluster but has limitations at extreme throughput levels. It uses mirrored queues and sharding for scalability but typically handles hundreds of thousands of messages per second, focusing on reliability over raw speed.</p> <p><span style="margin-left: 10px;"></span> When it comes to durability and message retention, Kafka retains messages for a configurable time (e.g., days or weeks), irrespective of consumption. This log-based retention ensures that even if a consumer fails, it can replay messages from the past, making Kafka suitable for event sourcing and data reprocessing. RabbitMQ ensures message durability by persisting messages to disk. However, once a message is acknowledged, it’s removed from the queue. This makes RabbitMQ more suitable for workflows where message replay is not required.</p> <p><span style="margin-left: 10px;"></span> For routing and flexibility, Kafka relies on its topic-based publish-subscribe model for routing. Messages are routed to topics, and consumers subscribe to specific partitions. This simplicity makes Kafka less flexible for complex routing scenarios. RabbitMQ offers advanced routing options through exchanges (direct, fanout, topic, headers). These options allow developers to implement complex routing rules, making RabbitMQ highly versatile.</p> <h3 id="error-handling-and-dead-letter-queues-dlqs">Error Handling and Dead Letter Queues (DLQs)</h3> <h4 id="kafka">Kafka</h4> <ul> <li>Message Failures: Kafka’s approach is based on retries and offset management. If a consumer fails to process a message, it can adjust its offset to reprocess the message. This makes error handling flexible but relies on developers to implement the correct retry logic.</li> <li>Dead Letter Queues: Kafka doesn’t natively support DLQs but provides mechanisms to implement them. For example, failed messages can be redirected to a separate “dead letter topic” using stream processing frameworks like Kafka Streams or with a custom consumer.</li> </ul> <h4 id="rabbitmq-1">RabbitMQ</h4> <ul> <li>Message Failures: RabbitMQ includes built-in support for message acknowledgments. If a consumer fails to acknowledge a message, RabbitMQ can requeue it for a configurable amount of times or send it to a Dead Letter Exchange (DLX).</li> <li>Dead Letter Queues: RabbitMQ’s DLX is an exchange where rejected messages are routed. This feature is straightforward to configure by setting specific queue parameters (x-dead-letter-exchange) to handle undeliverable messages.</li> </ul> <h3 id="message-ordering-and-idempotency">Message Ordering and Idempotency</h3> <h4 id="kafka-1">Kafka</h4> <ul> <li>Ordered Processing: Kafka ensures ordering within a partition. Producers decide the partition for each message, and messages within the same partition are processed in the order they arrive. Consumer groups distribute partitions among consumers, maintaining order at the partition level.</li> <li>Idempotency: Kafka supports idempotent producers to ensure that duplicate messages are not produced, even in retry scenarios. This is particularly useful for applications that require strict once-only delivery semantics.</li> </ul> <h4 id="rabbitmq-2">RabbitMQ</h4> <ul> <li>Ordered Processing: RabbitMQ does not guarantee message ordering, especially when using multiple consumers for a queue. Message ordering can break due to acknowledgments being processed out of sequence or consumer distribution.</li> <li>Idempotency: RabbitMQ leaves idempotency handling to the application layer. Developers must implement mechanisms to detect and handle duplicate messages, often by using unique message identifiers.</li> </ul> <h3 id="replication-and-disaster-recovery">Replication and Disaster Recovery</h3> <h4 id="kafka-2">Kafka</h4> <ul> <li>Partition Replication: Kafka ensures high availability through partition replication. Each partition has a leader and multiple followers. If the leader fails, one of the followers takes over.</li> <li>Failover Scenarios: Kafka’s ZooKeeper (or KRaft in newer versions) automatically manages leader election during failover. This ensures minimal disruption to message processing.</li> </ul> <h4 id="rabbitmq-3">RabbitMQ</h4> <ul> <li>Mirrored Queues: RabbitMQ offers mirrored queues to replicate messages across multiple nodes. If the primary node fails, a replica can take over.</li> <li>Failover Scenarios: Failover in RabbitMQ depends on clustering. While it provides high availability, managing clusters can be complex, especially for large-scale deployments.</li> </ul> <h2 id="hybrid-architectures">Hybrid Architectures</h2> <p><span style="margin-left: 10px;"></span> Hybrid architectures leverage the strengths of both Kafka and RabbitMQ to handle diverse requirements in a system. Instead of viewing Kafka and RabbitMQ as competitors, this approach integrates them to balance scalability, reliability, and functionality across various workloads. Let’s dive deeper into how this is achieved and explore specific examples, challenges, and best practices. I’m not a guru in this field, but in my mind makes sense we would use the best of both worlds. I didn’t find many information about this topic, but I’ll try to make the best of it.</p> <p><span style="margin-left: 10px;"></span> Hybrid architectures are beneficial because Kafka and RabbitMQ complement each other in terms of their core functionalities. Kafka shines in high-throughput scenarios that require real-time event streaming, distributed logging, and analytics. On the other hand, RabbitMQ is ideal for managing reliable, task-based messaging and handling point-to-point communication with advanced routing features. By using both tools, systems can take advantage of Kafka’s strengths in event streaming and RabbitMQ’s strengths in task management and message routing, leading to an architecture that optimizes performance, reliability, and scalability.</p> <p><span style="margin-left: 10px;"></span> When you need to handle diverse workloads, hybrid architectures provide the flexibility to use the right tool for the job. For instance, systems that require both real-time data processing and reliable task delivery can leverage Kafka for the data streaming aspects and RabbitMQ for the task management, ensuring that each function operates at its best.</p> <p><span style="margin-left: 10px;"></span> In a hybrid setup, Kafka and RabbitMQ interact in different ways depending on the specific needs of the system. One common pattern is to use Kafka for real-time event streams and RabbitMQ for task-based messaging. Kafka can process high-throughput events such as tracking user interactions or processing sensor data, and then RabbitMQ can take over to manage tasks like sending notifications, updating databases, or performing background processing based on those events.</p> <p><span style="margin-left: 10px;"></span> In an e-commerce platform, Kafka could be responsible for streaming real-time customer behavior data, such as page views, cart interactions, and purchases. This data can be used to power recommendation engines or provide marketing insights. Meanwhile, RabbitMQ could handle the actual order processing tasks like confirming payment, updating inventory, and sending emails or notifications to customers.</p> <p><span style="margin-left: 10px;"></span> Although it looks powerful, I think it would have some challenges. First, managing two systems can increase complexity. Kafka, with its distributed nature and partitioned topic structure, is fundamentally different from RabbitMQ’s queuing and task-based model. As a result, maintaining such an architecture requires expertise in both systems.</p> <p><span style="margin-left: 10px;"></span> Data synchronization can also be a challenge in hybrid architectures. Ensuring that data flows consistently and smoothly from one system to the other requires careful consideration, especially if messages are produced faster than they can be consumed.</p> <p><span style="margin-left: 10px;"></span> Monitoring and troubleshooting become more complex as well. Since Kafka and RabbitMQ are different tools with their own set of metrics and logging structures, effective monitoring requires using multiple tools to track both systems. It’s critical to implement a unified monitoring system that can track events across both Kafka and RabbitMQ to avoid performance bottlenecks and ensure smooth operations.</p> <h2 id="in-the-real-world">In the Real World</h2> <h3 id="apache-kafka-1">Apache Kafka</h3> <p>Netflix uses Apache Kafka for its real-time event streaming needs, to stream, process, and analyze this data in real-time. This enables capabilities like monitoring user activity, delivering personalized recommendations, and improving the system logging and diagnostics.</p> <p>LinkedIn, the creator of Kafka, uses it as the backbone for its activity streams. Kafka ensures high-throughput message delivery across LinkedIn’s services, such as tracking user interactions, delivering notifications, and supporting the real-time flow of information across its platform.</p> <p>Uber integrates Kafka to handle its real-time trip-tracking and pricing mechanisms. Uber’s platform generates streams of events, such as driver location updates and customer requests. Kafka processes this data in real-time to power features like dynamic pricing, which adjusts fares based on demand and supply, and to ensure that ride status updates are instantaneously reflected in the app.</p> <h3 id="rabbitmq-4">RabbitMQ</h3> <p>Airbnb relies on RabbitMQ for task queuing and reliable communication between its microservices. RabbitMQ ensures that critical tasks, such as confirming bookings or processing payments, are delivered and processed reliably even under high system load. This guarantees that no message is lost, making it an essential component.</p> <p>Mozilla employs RabbitMQ as part of its telemetry system. RabbitMQ handles millions of daily messages from Firefox users, which include performance data and error logs.</p> <p>Instagram uses RabbitMQ to manage asynchronous task processing, such as sending notifications, processing media uploads, and moderating content.</p> <table> <thead> <tr> <th><strong>Use Case</strong></th> <th><strong>Description</strong></th> <th><strong>Tool</strong></th> <th><strong>Real-World Example</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Real-time Analytics</strong></td> <td>Processing large volumes of streaming data for dashboards and insights.</td> <td>Kafka</td> <td><strong>Netflix</strong> for viewing trends and recommendations.</td> </tr> <tr> <td><strong>Task Queue Management</strong></td> <td>Asynchronous task processing where reliability and acknowledgment are critical.</td> <td>RabbitMQ</td> <td><strong>Instagram</strong> for notifications and media processing.</td> </tr> <tr> <td><strong>Event Sourcing</strong></td> <td>Capturing state changes as events to rebuild system state for auditability and reprocessing.</td> <td>Kafka</td> <td><strong>Uber</strong> for trip lifecycle management.</td> </tr> <tr> <td><strong>Microservices Communication</strong></td> <td>Enabling decoupled communication between microservices for scalable applications.</td> <td>RabbitMQ</td> <td><strong>Airbnb</strong> for managing inter-service communication in booking systems.</td> </tr> <tr> <td><strong>Log Aggregation</strong></td> <td>Collecting and centralizing logs from distributed systems for analysis.</td> <td>Kafka</td> <td><strong>LinkedIn</strong> for operational monitoring and debugging.</td> </tr> <tr> <td><strong>Data Pipelines</strong></td> <td>Streaming data from multiple sources to storage and processing systems.</td> <td>Kafka</td> <td><strong>Spotify</strong> for streaming user interactions to analytics platforms.</td> </tr> <tr> <td><strong>Data Streaming</strong></td> <td>Handling high-frequency data from devices in real-time.</td> <td>Kafka</td> <td><strong>Tesla</strong> for collecting telemetry data from vehicles.</td> </tr> <tr> <td><strong>Dynamic Pricing</strong></td> <td>Adjusting prices in real-time based on demand and supply.</td> <td>Kafka</td> <td><strong>Uber</strong> for surge pricing models.</td> </tr> <tr> <td><strong>Notification Systems</strong></td> <td>Sending real-time notifications to users across platforms.</td> <td>RabbitMQ</td> <td><strong>Instagram</strong> for user notifications on new messages and updates.</td> </tr> <tr> <td><strong>Financial Transactions</strong></td> <td>Ensuring reliable message delivery for payment systems.</td> <td>RabbitMQ</td> <td><strong>Stripe</strong> for managing payment workflows securely.</td> </tr> <tr> <td><strong>Content Moderation</strong></td> <td>Processing and flagging inappropriate content asynchronously.</td> <td>RabbitMQ</td> <td><strong>Reddit</strong> for detecting and moderating flagged user posts.</td> </tr> <tr> <td><strong>Supply Chain Tracking</strong></td> <td>Monitoring inventory levels and logistics in real-time.</td> <td>Kafka</td> <td><strong>Walmart</strong> for real-time inventory updates across stores.</td> </tr> <tr> <td><strong>Gaming Leaderboards</strong></td> <td>Streaming player activity data to generate real-time leaderboards.</td> <td>Kafka</td> <td><strong>League of Legends</strong> for updating player rankings dynamically.</td> </tr> </tbody> </table> <h2 id="conclusion">Conclusion</h2> <p>MENCIONAR O RABBITMQ QUE UTILIZEI NO SAG E TAMBEM MENCIONAR O REPO DE EVENT DRIVEN COM KAFKA</p> <p><span style="margin-left: 10px;"></span> Choosing between Apache Kafka and RabbitMQ isn’t just a technical decision—it’s about understanding the system’s needs and aligning those with the strengths of each tool. In my opinion, both are strong and mature tools, but they shine in different ways, and that’s what makes this comparison so interesting. It actually very interesting to understand how each architecture and structure have an impact on the usages of each tool.</p> <p><span style="margin-left: 10px;"></span> Kafka is like the powerhouse you call when you need to stream massive amounts of data in real-time, analyze it on the fly, and handle large amounts of data (million messages per second is no joke). It’s built for distributed systems, thrives in high-throughput environments, and is perfect for use cases like real-time analytics, data streams, and event sourcing. Its log-based retention and replayability make it an event-driven architecture perfect match. But let’s be real—it’s not the easiest tool to learn or manage, especially when you’re diving into topics, partitions, replication, and the complexities of ZooKeeper or KRaft. I’ve made a repository on event driven architecture with Kafka, and I can say that it was a challenge to understand the concepts and implement them. I still have a lot to learn about Kafka, but I think I’ll get there!</p> <p><span style="margin-left: 10px;"></span> RabbitMQ, on the other hand, is all about simplicity and reliability. It’s the go-to tool for task queues, asynchronous job processing, and microservices communication when you need messages delivered and acknowledged. Its flexibility with exchanges and protocols gives you all the routing options you could ask for, and it’s far easier to set up and use compared to Kafka. I’ve used RabbitMQ on a project I’m developing with a friend and the setup, the structure and the concept are much easier to understand and implement in comparison to Kafka. However, it’s not designed to scale in the same way Kafka is, and for scenarios involving massive data streams or real-time analytics, it might not be the smartest choice.</p> <p><span style="margin-left: 10px;"></span> At the end of the day, it’s all about the problem you’re solving. I know that this is a cliche, but it’s the truth! In the IT world is actually something that we have to keep in mind at all times, because the tools are not just tools, we need to have a good understanding of how they work to make informed choices. With that being said, if you’re building a scalable system to handle high-throughput, low-latency event streams, Kafka is your pick. If you’re managing complex routing and reliable message delivery between services, RabbitMQ might be a better fit. And if you’re somewhere in between, it’s worth considering whether these two tools can coexist in your stack, although it might add some complexity to your architecture.</p> <p><span style="margin-left: 10px;"></span> The goal isn’t just to pick the “best” tool but the right tool for your unique requirements. So, take a step back, think about your architecture, your team’s expertise, and the future scale of your system. And if you’re still stuck? Maybe it’s time to build a proof of concept and see these tools in action. Because at the end of the day, nothing beats real-world experimentation when it comes to figuring out what works best. This is one of the things that I learned in my journey as a developer, the best way to learn is by doing and discussing with experienced people.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Event-Driven Microservices with Kafka and RabbitMQ.]]></summary></entry><entry><title type="html">Big O Notation for Developers</title><link href="https://p-almeida12.github.io/blog/2024/big-o-notation/" rel="alternate" type="text/html" title="Big O Notation for Developers"/><published>2024-06-02T14:59:00+00:00</published><updated>2024-06-02T14:59:00+00:00</updated><id>https://p-almeida12.github.io/blog/2024/big-o-notation</id><content type="html" xml:base="https://p-almeida12.github.io/blog/2024/big-o-notation/"><![CDATA[<p><span style="margin-left: 10px;"></span> In the realm of computer science and software development, efficiency is extremely important. As the size of data and the complexity of operations increases, the performance of algorithms becomes a critical concern. Big O Notation is a mathematical concept that helps programmers understand and quantify the efficiency of their algorithms. In school, we always wondered why we needed math, all those formulas and equations with no sight of numbers. Well, Big O Notation is one of the reasons why math is essential in programming, and although we don’t like it, it is a necessary evil that can be of great help in optimizing our code.</p> <p><span style="margin-left: 10px;"></span> In this article, we explore the essential concept of Big O Notation and its significance in the world of programming. Understanding Big O Notation is crucial for evaluating and optimizing the performance of algorithms, ensuring efficient and scalable code. We will delve into what Big O Notation is, how it helps in analyzing algorithm complexity, and why mastering it is vital for every programmer aiming to write high-performance software.</p> <h2 id="what-is-big-o-notation">What is Big O Notation?</h2> <h3 id="definition-and-purpose">Definition and Purpose</h3> <p><span style="margin-left: 10px;"></span> Big O Notation is a mathematical concept used in computer science to describe the efficiency of algorithms in terms of time and space complexity. It provides a way to classify algorithms according to how their run time or space requirements grow as the input size increases. The primary purpose of Big O Notation is to give programmers a high-level understanding of the performance characteristics of an algorithm without getting lost in implementation details [<a href="https://www.simplilearn.com/big-o-notation-in-data-structure-article">https://www.simplilearn.com/big-o-notation-in-data-structure-article</a>].</p> <p><span style="margin-left: 10px;"></span> In essence, Big O Notation helps answer the question: “How does the algorithm’s performance change as the input size grows?” By focusing on the largest contributing factors, Big O Notation abstracts away constants and lower-order terms, allowing for a simplified analysis of an algorithm’s efficiency.</p> <h3 id="how-it-measures-time-and-space-complexity">How it Measures Time and Space Complexity</h3> <p><span style="margin-left: 10px;"></span> Time complexity refers to the amount of time an algorithm takes to complete as a function of the input size. It is measured in terms of the number of fundamental operations an algorithm performs relative to the size of the input. The key here is to understand how the time scales as the input size grows. For example, for an algorithm with a time complexity of O(n), the number of operations increases linearly with the input size. If the input size doubles, the time it takes to complete the algorithm also doubles.</p> <p><span style="margin-left: 10px;"></span> On the other hand, space complexity refers to the amount of memory an algorithm uses as a function of the input size. Space complexity measures the extra space or memory required by the algorithm, not counting the space needed for the input itself. Like time complexity, it focuses on how the memory requirements grow with the input size. For example, for an algorithm with a space complexity of O(n), the amount of memory needed grows linearly with the input size. If the input size doubles, the memory usage also doubles, following the same thought of the time complexity.</p> <h2 id="why-is-big-o-notation-important">Why is Big O Notation Important?</h2> <p><span style="margin-left: 10px;"></span> Understanding and applying Big O Notation is crucial for efficiency, scalability, and overall quality of software applications. Big O Notation is essential for programmers as it helps identify and select the most efficient algorithms based on their time complexity. By understanding how different algorithms scale with input size, developers can choose those that handle larger datasets or insert/delete more effectively. For instance, an algorithm with O(n log n) complexity will outperform an O(n^2) algorithm as data size increases. This knowledge is crucial for optimizing application performance, resulting in faster execution times and a better user experience.</p> <p><span style="margin-left: 10px;"></span> To make this analysis, we need to understand the existent Big O notations and how structures and algorithms are classified. Of course, we can’t know all of them, but keeping a cheat sheet handy can be a good idea. Further down this post, I will provide a table with the most common Big O notations.</p> <p><span style="margin-left: 10px;"></span> Scalability is another critical aspect addressed by Big O Notation. As applications grow and process more data, it’s crucial to ensure algorithms can scale efficiently. Algorithms with lower complexity usually ensure applications remain performant under increasing user loads, such as in web applications handling large and continuously growing<br/> amounts of user data.</p> <p><span style="margin-left: 10px;"></span> Moreover, Big O Notation promotes high code quality by encouraging developers to write clean, efficient, and maintainable code. Well-designed algorithms with optimal complexity not only perform better but also tend to be more readable and easier to maintain, leading to fewer bugs and simpler debugging processes.</p> <p><span style="margin-left: 10px;"></span> In conclusion, Big O Notation serves as a foundational tool for every programmer, providing insights into algorithm efficiency and scalability. By focusing on performance optimization, scalability, resource management, and code quality, developers can create robust, high-performance software capable of meeting the demands of today’s software.</p> <h2 id="common-big-o-notations">Common Big O Notations</h2> <p><span style="margin-left: 10px;"></span> Here are the most commonly encountered Big O Notations, along with their definitions and examples:</p> <table> <thead> <tr> <th style="text-align: left">Complexity</th> <th style="text-align: center">Name</th> <th style="text-align: right">Example</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">O(1)</td> <td style="text-align: center">Constant</td> <td style="text-align: right">Accessing an element in an array</td> </tr> <tr> <td style="text-align: left">O(log n)</td> <td style="text-align: center">Logarithmic</td> <td style="text-align: right">Binary search in a sorted array</td> </tr> <tr> <td style="text-align: left">O(n)</td> <td style="text-align: center">Linear</td> <td style="text-align: right">Iterating through an array</td> </tr> <tr> <td style="text-align: left">O(n log n)</td> <td style="text-align: center">Linearithmic</td> <td style="text-align: right">Efficient sorting algorithms (e.g., mergesort)</td> </tr> <tr> <td style="text-align: left">O(n^2)</td> <td style="text-align: center">Quadratic</td> <td style="text-align: right">Simple sorting algorithms (e.g., bubble sort)</td> </tr> <tr> <td style="text-align: left">O(2^n)</td> <td style="text-align: center">Exponential</td> <td style="text-align: right">Solving the Tower of Hanoi problem</td> </tr> <tr> <td style="text-align: left">O(n!)</td> <td style="text-align: center">Factorial</td> <td style="text-align: right">Generating all permutations of a list</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> I don’t think it’s necessary to further elaborate on the Big O Notation mentioned above, as they are self-explanatory.</p> <h2 id="importance-in-modern-software-development">Importance in Modern Software Development</h2> <p><span style="margin-left: 10px;"></span> In today’s fast-paced software development landscape, the ability to write efficient code is more critical than ever. With the exponential growth of data and the increasing complexity of operations, the performance of algorithms directly impacts the user experience and the scalability of applications. Big O Notation plays an extremely important role in modern software development by providing a framework for understanding and improving algorithm efficiency.</p> <p><span style="margin-left: 10px;"></span> Real-world applications often deal with vast amounts of data, whether it’s in search engines processing billions of queries per day, social media platforms managing terabytes of user-generated content, or financial systems executing thousands of transactions per second. In these scenarios, the choice of algorithms can significantly influence performance. By leveraging algorithms with optimal Big O characteristics, developers can ensure their applications remain performant and responsive under heavy loads.</p> <h2 id="case-studies-and-practical-examples">Case Studies and Practical Examples</h2> <p><span style="margin-left: 10px;"></span> To illustrate the practical applications of Big O Notation, let’s consider these 2 case studies of well-known algorithms that we encounter in everyday software development:</p> <h3 id="sorting-algorithms-quicksort-vs-bubble-sort">Sorting Algorithms: Quicksort vs. Bubble Sort</h3> <h4 id="quicksort">Quicksort:</h4> <ul> <li>Time Complexity of O(n log n) -&gt; on average</li> <li>How It Works: Quicksort is a divide-and-conquer algorithm. It works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.</li> <li>Efficiency: On average, Quicksort is very efficient, dividing the problem in half with each recursive call, leading to an average time complexity of O(n log n). This makes it suitable for large datasets.</li> </ul> <h4 id="bubble-sort">Bubble Sort:</h4> <ul> <li>Time Complexity: O(n^2) -&gt; on average</li> <li>How It Works: Bubble Sort is a simple comparison-based algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.</li> <li>Efficiency: Bubble Sort performs poorly on large datasets because it makes multiple passes through the list, with each pass having O(n) comparisons and potentially O(n) swaps, resulting in an overall time complexity of O(n^2).</li> </ul> <h4 id="comparison">Comparison:</h4> <p><span style="margin-left: 10px;"></span> For a dataset with 10,000 elements, Quicksort would, on average, take about 10,000 * log(10,000) = 10,000 * 4 = 40,000 operations.</p> <p><span style="margin-left: 10px;"></span> Bubble Sort, on the other hand, would take approximately 10,000 * 10,000 = 100,000,000 operations.</p> <p><span style="margin-left: 10px;"></span> According to this article <a href="https://mertmetin-1.medium.com/introduction-a12c801927a2">Bubble Sort Vs Quick Sort Algorithms</a>, as the dataset grows, the difference in performance becomes more pronounced. This example highlights why choosing Quicksort over Bubble Sort can lead to significant performance improvements for large datasets.</p> <h3 id="searching-algorithms-binary-search-vs-linear-search">Searching Algorithms: Binary Search vs. Linear Search</h3> <p><span style="margin-left: 10px;"></span> Searching is another common operation where algorithm choice is crucial for performance. Let’s compare Binary Search and Linear Search.</p> <h4 id="binary-search">Binary Search:</h4> <ul> <li>Time Complexity: O(log n)</li> <li>How It Works: Binary Search requires the array to be sorted. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, it narrows the interval to the lower half. Otherwise, it narrows it to the upper half. The process continues until the value is found or the interval is empty.</li> <li>Efficiency: Binary Search is highly efficient for large datasets because it reduces the problem size by half with each step. This logarithmic time complexity makes it much faster than linear search for large arrays.</li> </ul> <h4 id="linear-search">Linear Search:</h4> <ul> <li>Time Complexity: O(n)</li> <li>How It Works: Linear Search scans each element of the array sequentially until the desired value is found or the end of the array is reached.</li> <li>Efficiency: Linear Search performs well for small arrays or unsorted data but becomes inefficient as the size of the dataset increases because each element must be checked, resulting in a linear time complexity.</li> </ul> <h4 id="comparison-1">Comparison:</h4> <p><span style="margin-left: 10px;"></span> For a dataset with 1,000,000 elements, Binary Search would take log(1,000,000) ≈ 20 comparisons. Linear Search, in the worst case, would take up to 1,000,000 comparisons. As the dataset grows, Binary Search’s efficiency becomes even more significant. For instance, doubling the size of the dataset to 2,000,000 elements would only increase Binary Search comparisons to 21, while Linear Search comparisons would double to 2,000,000.</p> <p><span style="margin-left: 10px;"></span> By analyzing this study <a href="https://www.geeksforgeeks.org/linear-search-vs-binary-search/">Linear Search vs Binary Search</a> we can understand the importance of Big O Notation to select and implement the most efficient algorithms for specific tasks.</p> <h2 id="big-o-notation-for-developers">Big O Notation for Developers</h2> <p><span style="margin-left: 10px;"></span> Big O Notation is a fundamental concept in computer science that every developer should understand. It provides a high-level understanding of the efficiency of algorithms by describing their time and space complexity. For developers, understanding Big O Notation is crucial for writing efficient, scalable, and high-performance code.</p> <p><span style="margin-left: 10px;"></span> Java developers often deal with a variety of data structures and algorithms provided by the Java Collections Framework. Understanding the Big O Notation of these data structures and algorithms helps in making informed decisions when writing and optimizing code.</p> <h3 id="comparison-table-of-java-data-structures">Comparison Table of Java Data Structures</h3> <table> <thead> <tr> <th>Data Structure</th> <th>Access Time</th> <th>Insertion Time</th> <th>Deletion Time</th> <th>Order Preserved</th> <th>Best Use Case</th> </tr> </thead> <tbody> <tr> <td><strong>ArrayList</strong></td> <td>O(1)</td> <td>O(n)</td> <td>O(n)</td> <td>No</td> <td>Random access</td> </tr> <tr> <td><strong>LinkedList</strong></td> <td>O(n)</td> <td>O(1) at ends</td> <td>O(1) at ends</td> <td>No</td> <td>Frequent insertions/deletions at ends</td> </tr> <tr> <td><strong>HashSet</strong></td> <td>O(1)</td> <td>O(1)</td> <td>O(1)</td> <td>No</td> <td>Unique elements with fast lookups</td> </tr> <tr> <td><strong>LinkedHashSet</strong></td> <td>O(1)</td> <td>O(1)</td> <td>O(1)</td> <td>Yes</td> <td>Unique elements with insertion order maintained</td> </tr> <tr> <td><strong>TreeSet</strong></td> <td>O(log n)</td> <td>O(log n)</td> <td>O(log n)</td> <td>Yes (Sorted)</td> <td>Sorted unique elements</td> </tr> <tr> <td><strong>HashMap</strong></td> <td>O(1)</td> <td>O(1)</td> <td>O(1)</td> <td>No</td> <td>Fast key-value lookups</td> </tr> <tr> <td><strong>LinkedHashMap</strong></td> <td>O(1)</td> <td>O(1)</td> <td>O(1)</td> <td>Yes</td> <td>Fast lookups with insertion order maintained</td> </tr> <tr> <td><strong>TreeMap</strong></td> <td>O(log n)</td> <td>O(log n)</td> <td>O(log n)</td> <td>Yes (Sorted)</td> <td>Sorted key-value pairs</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> When choosing a data structure, Java developers need to consider the typical operations their application will perform. For example, if fast lookups are crucial, a HashMap might be the best choice. However, if ordered data is needed, a TreeMap or LinkedList might be more appropriate despite their higher access times.</p> <h3 id="comparison-table-of-java-sorting-algorithms">Comparison Table of Java Sorting Algorithms</h3> <table> <thead> <tr> <th>Sorting Algorithm</th> <th>Time Complexity (Best)</th> <th>Time Complexity (Average)</th> <th>Time Complexity (Worst)</th> <th>Space Complexity</th> <th>Best Use Case</th> </tr> </thead> <tbody> <tr> <td><strong>Collections.sort()</strong> (Timsort)</td> <td>O(n)</td> <td>O(n log n)</td> <td>O(n log n)</td> <td>O(n)</td> <td>For general-purpose sorting with objects</td> </tr> <tr> <td><strong>Arrays.sort()</strong> (Dual-Pivot Quicksort)</td> <td>O(n log n)</td> <td>O(n log n)</td> <td>O(n^2)</td> <td>O(log n)</td> <td>For sorting arrays of primitive types</td> </tr> <tr> <td><strong>Quicksort</strong></td> <td>O(n log n)</td> <td>O(n log n)</td> <td>O(n^2)</td> <td>O(log n)</td> <td>Fast in practice for large datasets</td> </tr> <tr> <td><strong>Mergesort</strong></td> <td>O(n log n)</td> <td>O(n log n)</td> <td>O(n log n)</td> <td>O(n)</td> <td>Linked lists or when stability is crucial</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> Sorting algorithms are another critical area where Big O Notation comes into play. Java’s Collections.sort() method uses Timsort, which has a time complexity of O(n log n). Knowing this helps developers understand that the sorting operation will scale efficiently with the size of the data.</p> <p><span style="margin-left: 10px;"></span> For backend web developers, efficiency and scalability are paramount. Understanding Big O Notation helps in optimizing server-side code to handle increasing loads and large datasets.</p> <h4 id="database-queries">Database Queries:</h4> <p>Understanding the time complexity of database operations is essential. For instance, indexing can reduce query time complexity from O(n) to O(log n). However, too many indexes can increase the time complexity of insertions and updates.</p> <h4 id="api-response-times">API Response Times:</h4> <p>Optimizing algorithms that process data before sending responses can significantly impact API performance. For example, filtering and sorting operations on server-side collections should use efficient algorithms to ensure fast response times.</p> <h4 id="caching-strategies">Caching Strategies:</h4> <p>Caching frequently accessed data can reduce the time complexity of retrieval operations from O(n) to O(1). Implementing efficient cache eviction practices can also be analyzed using Big O Notation to ensure optimal performance.</p> <p><span style="margin-left: 10px;"></span> When designing APIs, backend developers need to be mindful of the algorithms they use for data processing. For example, an API endpoint that sorts a large list of users should use a sorting algorithm with O(n log n) complexity rather than O(n^2).</p> <p><span style="margin-left: 10px;"></span> In addition, understanding the space complexity of data structures can help in managing memory usage effectively. For example, using a linked list for a large dataset might lead to high memory overhead due to the storage of pointers, whereas an array-based list might be more memory-efficient.</p> <h2 id="conclusion">Conclusion</h2> <p><span style="margin-left: 10px;"></span> In the world of computer science and software development, mastering Big O Notation is like having a superpower. It empowers developers to make informed decisions about the efficiency and scalability of their algorithms, which is critical in our data-driven and performance-conscious era.</p> <p><span style="margin-left: 10px;"></span> By understanding Big O Notation, you gain insights into how algorithms perform as the size of the input grows. This understanding allows you to optimize your code, ensuring that your applications run faster and handle larger datasets more gracefully. When working on a small personal project, Big O notation might not make much difference, but in a massive enterprise system, choosing the right algorithm can mean the difference between a smooth user experience and a sluggish, unresponsive application.</p> <p><span style="margin-left: 10px;"></span> The examples of Quicksort versus Bubble Sort and Binary Search versus Linear Search illustrate just how crucial algorithm selection can be. Quicksort’s O(n log n) time complexity makes it a go-to for sorting large datasets efficiently, while Bubble Sort’s O(n^2) complexity shows why it’s best left to educational purposes rather than real-world applications. Similarly, Binary Search’s O(log n) complexity highlights its effectiveness for large, sorted datasets compared to the O(n) linear search.</p> <p><span style="margin-left: 10px;"></span> For developers, understanding the Big O complexities of common data structures and algorithms, especially those in the Java Collections Framework, is indispensable. This knowledge helps in selecting the right tool for the job, whether it’s an ArrayList for fast access, a HashMap for quick lookups, or a TreeMap for ordered data.</p> <p><span style="margin-left: 10px;"></span> Backend developers, too, benefit immensely from this knowledge. Efficient database querying, speedy API responses, and effective caching strategies all hinge on the principles of Big O Notation. By optimizing server-side algorithms, you can handle increasing loads and large datasets with ease, ensuring your application remains responsive and performant.</p> <p><span style="margin-left: 10px;"></span> In short, Big O Notation is more than just a theoretical concept; it’s a practical tool that every developer should have in their toolkit. It promotes high-quality code that’s not only efficient and scalable but also maintainable and robust. So, next time you’re writing or reviewing code, take a moment to consider the Big O implications. Feel free to check out these cheat sheets for a quick reference to common Big O complexities! <a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a> and <a href="https://gist.github.com/marcinjackowiak/85f144d0f1ed5fd066d4d2a34961497c">https://gist.github.com/marcinjackowiak/85f144d0f1ed5fd066d4d2a34961497c/</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Big O Notation and code efficiency.]]></summary></entry><entry><title type="html">The Rise of Reactive Programming with Spring WebFlux - A Game Changer or Overkill?</title><link href="https://p-almeida12.github.io/blog/2023/reactive-spring-webflux/" rel="alternate" type="text/html" title="The Rise of Reactive Programming with Spring WebFlux - A Game Changer or Overkill?"/><published>2023-10-18T15:59:00+00:00</published><updated>2023-10-18T15:59:00+00:00</updated><id>https://p-almeida12.github.io/blog/2023/reactive-spring-webflux</id><content type="html" xml:base="https://p-almeida12.github.io/blog/2023/reactive-spring-webflux/"><![CDATA[<p><span style="margin-left: 10px;"></span>Reactive programming has sparked a revolution in the realm of software development. With its capacity to efficiently handle large-scale, highly concurrent systems, it has become the go-to approach for building modern, responsive applications. In the world of Java development, Spring WebFlux has emerged as a formidable framework, offering developers the tools they need to harness the power of reactive programming.</p> <p><span style="margin-left: 10px;"></span>In this article, we embark on a journey through the landscape of reactive programming and its impact on the world of Java development. We’ll delve into the core principles that define reactive programming and explore how it transforms the way we approach application design. We will focus on Spring WebFlux, the driving force behind reactive Java applications, as we examine its capabilities and shed light on why it has gained momentum in recent years.</p> <h2 id="understanding-reactive-programming">Understanding Reactive Programming</h2> <p><span style="margin-left: 10px;"></span>Right now, in the IT community, the term “Reactive” is getting a little bit overloaded/abused, so according to the Reactive Manifesto (https://www.reactivemanifesto.org), the reactive systems are Responsive, Resilient, Elastic and Message Driven. The term “reactive” in the context of programming models revolves around the idea of reacting to change, such as components responding to various events like I/O or user input. Feel free to read the manifesto for a better understanding of this concepts.</p> <p><span style="margin-left: 10px;"></span>Complex systems are built from smaller, interconnected components, and their behavior hinges on the responsiveness of these constituent elements. This implies that Reactive Systems employ a set of design principles to ensure that these responsive properties are consistently exhibited across all levels of scale within the system, enabling seamless composability. In essence, every building block, whether large or small, is designed to exhibit reactive characteristics, allowing them to work in harmony and combine effectively to create a cohesive and adaptable system.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 1 - Reactive System (https://www.reactivemanifesto.org) </div> <p><span style="margin-left: 10px;"></span>Now that we have a better understanding of what the term “Reactive” really stands for, we can dive into Reactive Programming. Reactive programming is an implementation technique, a tool, that focuses on non-blocking, asynchronous execution, a key characteristic of Reactive Systems.</p> <p><span style="margin-left: 10px;"></span>Reactive programming is an asynchronous programming paradigm focused on streams of data an events in a non-blocking way. According to Gerad Berry, a French Computer Scientist, these programs also maintain a continuous interaction with their environment, not the program itself. Interactive programs work at their own pace, while reactive programs only work in response to external demands. That being said, the first one, tends to block threads, leading to performance bottlenecks and decreased system responsiveness. In contrast, the second one, uses non-blocking I/O operations, allowing applications to handle more requests concurrently with a faster response time.</p> <p><span style="margin-left: 10px;"></span>The Non-blocking concept is very important. In Blocking, the code will stop and wait for more data (ie reading from disk, network, etc). Non-blocking in contrast, will process available data, ask to be notified when more is available and then continue. In the images below, we can have a better understanding of what Non-blocking consists.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Figure 2 - Multi Thread Server (https://javarevisited.blogspot.com/2017/03/why-we-use-threads-in-java.html) and Figure 3 - Node.js Server (https://strongloop.com/strongblog/node-js-is-faster-than-java/) </div> <p><span style="margin-left: 10px;"></span>Java developers always have been pretty comfortable using Multi Threaded Servers, where we have a thread pool that take a given number os requests. When a given thread receives a request, it will get suspended while is waiting for a resource. This starting and stopping of the threads is pretty common and Java handles it very efficiently, so its not necessarily a bad programming paradigm and it has been around for a long time.</p> <p><span style="margin-left: 10px;"></span>In contrast, we have the Node.js server that uses different techniques to manage the threads. In the Figure 3 above, a request comes in and we have a single thread in loop to the the work, that delegates the requests to async threads as they come in. As we can see we have no waiting threads, at all times all the threads are processing, which can improve efficiency and performance. But this isn’t properly a good thing, imagine that something on the event loop takes a lot of CPU, that can really bring down Node.js performance, not to talk about the callback hell that Node.js is known for. It is a significantly different paradigm because your requests are expected to complete quickly on that event loop and get off of it.</p> <p><span style="margin-left: 10px;"></span>Another feature of reactive programming is the Back Pressure. Back Pressure is the ability of the subscriber to throttle data, to help avoid issues as buffering and blocking. Throttling is the practice of controlling the quantity of data that can be exchanged between two systems within a specific time frame. Typically, this is implemented to avoid one system overwhelming another with an excessive data load or to ensure that an individual user does not excessively deplete a shared resource. The failures are also a little different as well, since exceptions are not thrown in a traditional sense, since it would break the stream. Exceptions are processed by a handler function.</p> <h2 id="what-is-spring-webflux">What is Spring WebFlux?</h2> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_4.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 4 - Spring WebFlux (https://blog.onesaitplatform.com/en/2022/07/13/reactive-programming-spring-webflux/) </div> <p><span style="margin-left: 10px;"></span>WebFlux is a reactive programming model for building web applications and is a part of the Spring Framework ecosystem. Based on the documentation, it was created with two primary needs: Concurrency and Resource Efficiency and Functional Programming. It is built on top of the Reactive Streams API, which provides a model to build web applications on the JVM.</p> <p><span style="margin-left: 10px;"></span>Reactor is the reactive library for Spring WebFlux. It offers the Mono and Flux API types to work with data sequences of 0 to 1 and 0 to many, using a comprehensive set of operators aligned with the ReactiveX operator vocabulary. As a Reactive Streams library, Reactor ensures support for non-blocking back pressure.</p> <p><span style="margin-left: 10px;"></span>Spring WebFlux has two main components: the RouterFunction and the HandlerFunction. The RouterFunction serves the purpose of associating incoming requests with their corresponding HandlerFunction. The role of the HandlerFunction is to manage the request and provide a response. The objective of the Reactive Stream API is to create a standard for asynchronous stream processing with a non-blocking back pressure. There are two main components: the Publisher and the Subscriber. The publisher emits the data and the subscriber consumes it.</p> <p><span style="margin-left: 10px;"></span>For instance, a data repository acting as a Publisher can produce data, while an HTTP server acting as a Subscriber can write this data to the response. The primary purpose of Reactive Streams is to enable the subscriber to control the pace at which the publisher produces data, ensuring a balanced flow of information.</p> <h2 id="spring-webflux--spring-mvc">Spring WebFlux &amp; Spring MVC</h2> <p><span style="margin-left: 10px;"></span>I think by now we can have a pretty good idea where both of these paradigms differ. Although they’re both designed to build web applications, one uses a blocking approach and the other one uses a non-blocking approach. Spring Web MVC traditionally incorporates the servlet API and operates within a servlet container, which are by nature blocking as well as JDBC and JPA. In Spring WebFlux, the web server does not use the servlet container, because it is using a new stack underneath that. Although Spring made a really good job keeping it abstract to us developers, we must keep in mind that Web MVC components are blocking!</p> <p><span style="margin-left: 10px;"></span>But the real question is: which one is better? Is Spring WebFlux that good has it seems to be? And the answer is simple, it depends. I know, cliché, but its my honest opinion and a lot of times, especially in Software Engineering, is actually true. We can’t choose one over the other based only on this, we need to be skeptical and understand what are the needs of the program we are about to develop. That being said, let’s take a look at where and when one paradigm can be better than the other.</p> <h3 id="spring-webflux">Spring WebFlux</h3> <p><span style="margin-left: 10px;"></span>Spring WebFlux is ideal for applications that need to handle a large number of concurrent requests and require high scalability. For example, a high-traffic e-commerce website, that needs to handle a large number of concurrent requests. If your application deals with streams of data or events, such as real-time updates, IoT devices, or message-driven architectures, WebFlux enables handling of asynchronous operations and provides built-in support for WebSocket communication. It’s also really good with microservices and if your team is into functional programming, it will be worth your while for sure!</p> <h3 id="spring-mvc">Spring MVC</h3> <p><span style="margin-left: 10px;"></span>Spring MVC is a suitable choice when your application primarily handles synchronous request processing and doesn’t require the high concurrency and scalability benefits of reactive programming. Spring MVC has a widely adopted and mature ecosystem, making it a dependable choice for many applications. The existence of heavy dependency on Spring MVC libraries or if the project relies on blocking I/O operations, migrate it to Spring WebFlux can be tricky. It really comes down to the needs of your existent program and the experience of the team you’re working with, sometimes Spring MVC is the way to go.</p> <h2 id="performance-considerations">Performance Considerations</h2> <p><span style="margin-left: 10px;"></span>In my GitHub profile, I have repositories where I used Spring MVC and where I used Spring WebFlux and thats the reason I’m writing this article, to share my journey and what I could learn while doing it. So, if we take into consideration the performance of both approaches, we can take this example of my projects.</p> <p><span style="margin-left: 10px;"></span>Let’s consider a scenario where we need to handle multiple concurrent requests for fetching data from a remote service. We’ll compare the performance of Spring WebFlux and Spring MVC in this situation.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_6.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 4 - Spring WebFlux example. </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/post1_7.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Figure 5 - Spring Web MVC example. </div> <p><span style="margin-left: 10px;"></span>In the WebFlux example, when a non-blocking request is made, the server thread efficiently manages other incoming requests while it awaits the response. This capability empowers the server to handle a larger number of concurrent requests, all with a reduced need of numerous threads. This results in a significant enhancement in scalability, as the server can efficiently serve multiple clients simultaneously.</p> <p><span style="margin-left: 10px;"></span>On the other hand, in the MVC example, synchronous requests are processed, and the server thread remains engaged until the response is received. This conventional approach poses limitations on the number of concurrent requests the server can effectively manage. Consequently, this method may experience performance degradation when subjected to high workloads, as the server’s resources can become bottlenecked due to the blocking nature of request processing.</p> <p><span style="margin-left: 10px;"></span>According to a <a href="https://medium.com/deno-the-complete-reference/spring-boot-vs-spring-webflux-performance-comparison-for-hello-world-case-386da4e9c418">Medium</a> post, where they compare WebFlux to Web MVC, the Spring Boot (threadpool), Spring WebFlux demonstrates noticeable performance advantages, particularly in terms of requests per second and response times. It achieves approximately double the RPS compared to Spring Boot while maintaining a similar resource cost. The performance characteristics differ based on concurrency levels. At lower concurrency levels, Spring WebFlux exhibits superior median response times. However, at higher levels of concurrency, Spring Boot outperforms Spring WebFlux. Feel free to read their post and analyze their research.</p> <p><span style="margin-left: 10px;"></span>But keep in mind, reactive and non-blocking programming may not inherently make applications run faster. They can enhance performance in certain scenarios, such as when using WebClient for parallel remote calls, but typically, they entail more complex implementation and may slightly increase processing time. Never the less, their primary advantage lies in the ability to scale effectively with a fixed number of threads and reduced memory usage. This scalability improves application resilience under heavy loads, offering more predictable performance. The true benefits of reactive and non-blocking become apparent in situations with latency, including slow and unpredictable network, where the reactive approach excels and can lead to significant performance improvements.</p> <h2 id="the-final-verdict">The Final Verdict</h2> <p><span style="margin-left: 10px;"></span>The moment we were all waiting for: the verdict. At least mine. After reading multiple posts of other fellow developers and enthusiasts, some think that Reactive Programming isn’t that big of a deal and others think it will take Java to the next level. Throughout this section I will try to be as impartial as possible, so we can actually take something from this and make up our own minds.</p> <p><span style="margin-left: 10px;"></span>Let’s start with the concept of Non-Blocking, if we need to make a call, then block to wait for the response and then handle the response because we need that same thread, we can’t and we’re not using Reactive, because we can get into an event loop and stop the application. What I’m trying to say is that everything that uses ThreadLocal, the Java special class that allows us to store data that will be accessible only by a specific thread, is not compatible with reactive. You might think “That isn’t that big of a deal, just don’t use it!”, well I’m afraid that sometimes it might not be possible. Like I said before, JDBC, for example, is intrinsically blocking, its not something we can switch on and off. It is dependent of the ThreadLocal to allow rollbacks, because it holds the transaction, and if we’re working with old JDBC databases, migration can be painful (trust me). The database driver must use the R2DBC spec in order to work with non-blocking calls. One important thing to mention, that sometimes can go unnoticed, is fact that REST calls aren’t blocking, because, in Spring WebClient, they’re not thread-dependent, meaning that the request thread doesn’t have to be the response thread.</p> <p><span style="margin-left: 10px;"></span>If f your application is already handling loads efficiently using traditional MVC or by resorting to horizontal scaling, it may not be the most prudent business decision to opt for WebFlux. In such cases, the additional complexity and resource allocation required by WebFlux might outweigh the potential benefits it offers, making it less compelling from a cost-benefit perspective. So reactive and non-reactive paradigms cannot be mixed, which means that the application has to be reactive end to end. It’s not impossible, but integrating blocking code into a reactive pipeline can be challenging for what I could gather and is an anti-pattern approach for me. Not to talk about debugging, the process that we learnt in the first day of college can become quite hard if the pipeline isn’t correctly built.</p> <p><span style="margin-left: 10px;"></span>Apart from the performance benefits, I found it cognitively complex, hard to read nested code, hard to debug and divides the ecosystem efforts. It’s hard enough to keep complicated synchronous code working and adding the complexity of these non-blocking apis only further complicates already complicated code. This could have been the projects issue. By harder to maintain I mean adding certain features. Sometimes this required to rewrite whole chains instead of simply adding to the existing code. Plain imperative sequential code is much much easier to reason about, and therefore maintain and evolve, than reactive code. This can lead to a team spending more time having to fix technical issues than they are adding business value and for someone who doesn’t have that much experience like me, the code can be unreadable, unlike other approaches that even though we’re not used to we can get around.</p> <p><span style="margin-left: 10px;"></span>As i was scavenging the internet, I began to understand that almost everyone doesn’t really need reactive, they think it will be the savior and it will resolve all their performance problems. Well that’s most definitely not true, WebFlux is used for very specific needs where the advantages surpass the downsides. And with the rise of Loom Project, these APIs begin to stay behind. I strongly recommend you to check out the Loom project, it can be a game changer. While I remain skeptical that Loom will serve as a silver bullet solution for these issues, I do hold the hope that the adoption of more linear control flows will enhance the readability and writability of code. There’s a certain comfort in following the familiar path of writing straightforward imperative code. Additionally, with the impending arrival of Virtual Threads, the value proposition of transitioning to a reactive approach appears to be somewhat diminished. These advancements lead me to question whether the adoption of reactive programming is as compelling as it once was.</p> <p><span style="margin-left: 10px;"></span>In a nutshell, if you find yourself in a position where you are willing to make a trade-off, sacrificing a degree of simplicity in exchange for the potential performance enhancements, then embracing reactive programming could be a strategic decision that aligns with the specific needs and goals of your project. It’s an approach that allows you to harness the power of asynchronous, non-blocking operations to cater to high-concurrency scenarios, thereby unlocking new possibilities for your application’s scalability and responsiveness.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Reactive Programming and Spring WebFlux]]></summary></entry></feed>