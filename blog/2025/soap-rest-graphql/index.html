<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>SOAP, REST, and GraphQL - My experience | Paulo Almeida</title> <meta name="author" content="Paulo Almeida"> <meta name="description" content="SOAP, REST, and GraphQL - trying to compare the uncomparable."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%90&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://p-almeida12.github.io/blog/2025/soap-rest-graphql/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Paulo </span>Almeida</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">SOAP, REST, and GraphQL - My experience</h1> <p class="post-meta">August 4, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#are-soap-rest-and-graphql-comparable">Are SOAP, REST, and GraphQL Comparable?</a> <ul> <li class="toc-entry toc-h2"> <a href="#soap">SOAP</a> <ul> <li class="toc-entry toc-h3"><a href="#architecture">Architecture</a></li> <li class="toc-entry toc-h3"><a href="#strengths-and-weaknesses">Strengths and Weaknesses</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#rest">REST</a> <ul> <li class="toc-entry toc-h3"><a href="#architecture-1">Architecture</a></li> <li class="toc-entry toc-h3"><a href="#strengths-and-weaknesses-1">Strengths and Weaknesses</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#graphql">GraphQL</a> <ul> <li class="toc-entry toc-h3"><a href="#architecture-2">Architecture</a></li> <li class="toc-entry toc-h3"><a href="#strengths-and-weaknesses-2">Strengths and Weaknesses</a></li> <li class="toc-entry toc-h3"><a href="#the-n1-problem--and-the-dgs-solution">The N+1 Problem — and the DGS Solution</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#final-thoughts">Final Thoughts</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p><span style="margin-left: 10px;"></span> APIs define how services talk, how frontends fetch data, and ultimately how systems scale. Throughout my career, I’ve spent most of my time working with REST APIs in enterprise contexts.</p> <p><span style="margin-left: 10px;"></span> In a recent personal project with a friend, I migrated from REST to GraphQL (using Netflix DGS) to overcome data-fetching inefficiencies. I’ve also tinkered with SOAP, though never in production — enough to appreciate its design philosophy and understand why it still powers parts of the enterprise world.</p> <p><span style="margin-left: 10px;"></span> This post is my deep dive into SOAP, REST, and GraphQL — how they differ, how they compare (or don’t), and what lessons I’ve learned from working with them.</p> <h1 id="are-soap-rest-and-graphql-comparable">Are SOAP, REST, and GraphQL Comparable?</h1> <p><span style="margin-left: 10px;"></span> At first glance, these three might seem like direct competitors — but they’re not perfectly comparable.</p> <table> <thead> <tr> <th><strong>Comparison Aspect</strong></th> <th><strong>SOAP</strong></th> <th><strong>REST</strong></th> <th><strong>GraphQL</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Category</strong></td> <td>Communication protocol.</td> <td>Architectural style</td> <td>Query language.</td> </tr> <tr> <td><strong>Level of abstraction</strong></td> <td>Low-level, rigid.</td> <td>Conceptual and flexible</td> <td>Declarative and client-driven.</td> </tr> <tr> <td><strong>Intent</strong></td> <td>Standardized data exchange.</td> <td>Resource-oriented access</td> <td>Flexible, client-specific data queries.</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> In short:</p> <ul> <li>SOAP is a protocol — like a contractually defined tunnel between systems.</li> <li>REST is a style — a set of guiding principles for web-based resource communication.</li> <li>GraphQL is a language/runtime layered on top of HTTP — a tool to query data in a declarative, efficient way.</li> </ul> <p><span style="margin-left: 10px;"></span> So while they all enable API communication, they do it at different levels of abstraction and serve different design goals. Comparing them might seem wrong, but its possible, we just need to keep in mind that they are different and optimized for different situations.</p> <h2 id="soap">SOAP</h2> <p><span style="margin-left: 10px;"></span> SOAP (Simple Object Access Protocol) was designed for interoperability in large, distributed systems. It enforces a strict structure using XML envelopes, WSDL contracts, and WS-extensions for things like security, transactions, and reliable messaging.</p> <p><span style="margin-left: 10px;"></span> SOAP message example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;soap:Header&gt;
    &lt;auth:Token&gt;VerYsECUreTOkeN124&lt;/auth:Token&gt;
  &lt;/soap:Header&gt;
  &lt;soap:Body&gt;
    &lt;m:GetBeer xmlns:m="http://goodbeer.com/beers"&gt;
      &lt;m:BeerId&gt;42&lt;/m:BeerId&gt;
    &lt;/m:GetBeer&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</code></pre></div></div> <h3 id="architecture">Architecture</h3> <p><span style="margin-left: 10px;"></span> SOAP follows a strictly layered and contract-driven architecture. It was designed to ensure interoperability between systems written in different languages and running on different platforms. The architecture is protocol-centric, with a focus on message structure, transport abstraction, and formal service contracts.</p> <p><span style="margin-left: 10px;"></span> At its core, a SOAP system consists of:</p> <ul> <li>SOAP Envelope — the root XML element that defines the start and end of the message.</li> <li>Header — optional section that carries metadata such as authentication tokens, transaction IDs, or routing information.</li> <li>Body — contains the actual request or response payload.</li> <li>Fault Element — a special XML element used for standardized error reporting.</li> </ul> <p><span style="margin-left: 10px;"></span> SOAP services are usually defined by a WSDL (Web Services Description Language) file. The WSDL acts as a contract that describes:</p> <ul> <li>The available operations (methods) and their parameters.</li> <li>The XML schema (XSD) defining the structure of input/output data.</li> <li>The binding details (which protocol and encoding are used).</li> <li>The service endpoint (where the service lives).</li> </ul> <p><span style="margin-left: 10px;"></span> When a client consumes a SOAP service, it typically:</p> <ol> <li>Parses the WSDL to generate client-side proxy classes.</li> <li>Constructs a XML request message conforming to the schema.</li> <li>Sends the message over a chosen transport (HTTP, SMTP, or others).</li> <li>Receives an XML response and deserializes it into native objects.</li> </ol> <p><span style="margin-left: 10px;"></span> Because SOAP is transport-independent, it can use multiple communication protocols. HTTP is the most common, but SOAP can also run over JMS (Java Message Service) for asynchronous enterprise communication.</p> <p><span style="margin-left: 10px;"></span> This rigidity brings predictability and strong validation, but also makes SOAP services heavier and harder to evolve. Every change in schema or contract typically requires regenerating stubs and revalidating clients.</p> <h3 id="strengths-and-weaknesses">Strengths and Weaknesses</h3> <table> <thead> <tr> <th><strong>Pros</strong></th> <th><strong>Cons</strong></th> </tr> </thead> <tbody> <tr> <td>Strong typing and contract-first design with WSDL</td> <td>Verbose XML payloads increase complexity</td> </tr> <tr> <td>Built-in standards for security and reliability (WS-Security, WS-ReliableMessaging)</td> <td>Harder to integrate with lightweight clients (web, mobile)</td> </tr> <tr> <td>Transport-agnostic (HTTP, SMTP, TCP, etc.)</td> <td>Tooling can feel heavy and outdated</td> </tr> <tr> <td>Excellent for regulated industries (finance, telecom, insurance)</td> <td>Difficult to evolve and version APIs flexibly</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> When I experimented with SOAP, I found it, for lack of a better word, “elegant”: you get guarantees, schemas, and rigid consistency. But in practice, the verbosity and dependency on specialized tooling (like JAX-WS or WSDL generators) made it feel awkward for modern distributed systems.</p> <p><span style="margin-left: 10px;"></span> SOAP is a tank — extremely reliable but slow and rigid. For systems where every transaction must be traceable, it still earns its place. But for web APIs that need agility, it’s probably not my first choice.</p> <h2 id="rest">REST</h2> <p><span style="margin-left: 10px;"></span> REST (Representational State Transfer) redefined how we think about APIs. Instead of operations, REST focuses on resources — entities exposed through predictable URLs and standard HTTP verbs.</p> <p><span style="margin-left: 10px;"></span> For example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /beers/123
PUT /beers/123
DELETE /beers/123
</code></pre></div></div> <p><span style="margin-left: 10px;"></span> REST emphasizes:</p> <ul> <li>Statelessness — each request contains everything needed.</li> <li>Uniform interface — clients and servers communicate via standard verbs.</li> <li>Cacheability — responses can be cached via HTTP.</li> <li>Layered system — intermediaries can optimize performance.</li> </ul> <h3 id="architecture-1">Architecture</h3> <p><span style="margin-left: 10px;"></span> REST is an architectural style, not a protocol. Its architecture revolves around a set of constraints defined by Roy Fielding, which make web systems scalable, cacheable, and loosely coupled.</p> <p><span style="margin-left: 10px;"></span> A RESTful system is organized around resources — conceptual entities exposed via URIs. Each resource can have multiple representations (usually JSON or XML) and is manipulated through standard HTTP verbs.</p> <p><span style="margin-left: 10px;"></span> The key architectural constraints of REST are:</p> <ol> <li>Client-Server Separation — clients handle UI and state, servers handle data and logic.</li> <li>Statelessness — every request from the client must contain all information needed by the server. The server doesn’t store client session state.</li> <li>Cacheability — responses must define themselves as cacheable or not, enabling intermediate caches (CDNs, proxies).</li> <li>Uniform Interface — consistent behavior across all endpoints via HTTP verbs and standard response codes.</li> <li>Layered System — clients don’t need to know whether they’re talking directly to the server or through intermediaries.</li> <li>Optional Code on Demand — servers can return executable code (e.g., JavaScript) to clients.</li> </ol> <p><span style="margin-left: 10px;"></span> A typical REST architecture looks like this:</p> <ul> <li>Client layer — browsers, mobile apps, or other services making HTTP calls.</li> <li>API Gateway / Load Balancer — handles routing, authentication, rate limiting.</li> <li>Application layer — REST controllers or handlers process requests, apply business logic, and access data sources.</li> <li>Persistence layer — databases or external systems providing the underlying data.</li> </ul> <p><span style="margin-left: 10px;"></span> Data is exchanged through representations (usually JSON), with HATEOAS (Hypermedia as the Engine of Application State) being a powerful concept — embedding links in responses to guide clients through available actions.</p> <p><span style="margin-left: 10px;"></span> In microservice environments, REST APIs are often interconnected through internal HTTP calls or API gateways like Kong, NGINX, or Spring Cloud Gateway. Each microservice maintains its own resources, forming a loosely coupled ecosystem.</p> <p><span style="margin-left: 10px;"></span> The architectural simplicity and alignment with web standards are what make REST so ubiquitous — but its statelessness and fixed endpoints can create inefficiencies when clients need complex, nested data.</p> <p><span style="margin-left: 10px;"></span> I found this post by Fielding very clarifying and interesting: <a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="external nofollow noopener" target="_blank">https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a>.</p> <h3 id="strengths-and-weaknesses-1">Strengths and Weaknesses</h3> <table> <thead> <tr> <th><strong>Pros</strong></th> <th><strong>Cons</strong></th> </tr> </thead> <tbody> <tr> <td>Simple, human-readable, easy to test and debug</td> <td>Over-fetching: clients often get more data than needed</td> </tr> <tr> <td>Natively supported by web infrastructure</td> <td>Under-fetching: multiple requests to build composite views</td> </tr> <tr> <td>Tooling and standards (OpenAPI, Swagger, Postman) are mature</td> <td>Versioning can be messy (/v1/, /v2/, etc.)</td> </tr> <tr> <td>Easy integration with browsers, mobile apps</td> <td>Limited flexibility for complex or nested data</td> </tr> <tr> <td>Ideal for microservices and stateless systems</td> <td>Can become chatty (many endpoints, round-trips)</td> </tr> </tbody> </table> <p><span style="margin-left: 10px;"></span> At work, REST is the backbone of our service-to-service communication. It’s pragmatic, reliable, and well-understood by everyone — from backend to frontend engineers.</p> <p><span style="margin-left: 10px;"></span> However, over time I’ve fought the classic REST challenges, both at work and in my personal projects:</p> <ul> <li>Endpoints proliferating (/beer, /beer/details, /beer/details/extended).</li> <li>UIs needing multiple requests for a single view.</li> <li>The friction of maintaining backward compatibility when clients depend on specific payload shapes.</li> </ul> <p><span style="margin-left: 10px;"></span> These trade-offs eventually led me to explore GraphQL for my personal projects.</p> <h2 id="graphql">GraphQL</h2> <p><span style="margin-left: 10px;"></span> GraphQL represents a shift from resource-oriented design (REST) to data-oriented design.</p> <p><span style="margin-left: 10px;"></span> Instead of defining how clients access resources, we define what data exists, and let clients query the exact shape they need.</p> <p><span style="margin-left: 10px;"></span> Single endpoint: /graphql</p> <p><span style="margin-left: 10px;"></span> Example query:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query {
  brewery(id: 1) {
    name
    beers {
      name
      reviews {
        text
      }
    }
  }
}
</code></pre></div></div> <p><span style="margin-left: 10px;"></span> Server responds exactly with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "data": {
    "brewery": {
      "name": "Super Bock Brewery",
      "beers": [
        {
          "name": "Super Bock Original",
          "reviews": [
            { "text": "Smooth!" },
            { "text": "Perfect summer beer." }
          ]
        },
        {
          "name": "Stout",
          "reviews": [
            { "text": "Good." }
          ]
        }
      ]
    }
  }
}
</code></pre></div></div> <h3 id="architecture-2">Architecture</h3> <p><span style="margin-left: 10px;"></span> GraphQL’s architecture flips the REST model by introducing a query engine between the client and the data sources. Instead of exposing multiple endpoints, GraphQL exposes a single endpoint that accepts declarative queries describing the exact shape of the data the client wants.</p> <p><span style="margin-left: 10px;"></span> At a high level, a GraphQL system consists of:</p> <ul> <li>Schema Definition Layer — written in SDL (Schema Definition Language), describing types, queries, mutations, and relationships.</li> <li>Execution Layer (Resolvers / Data Fetchers) — functions that fetch data for specific fields or types.</li> <li>Query Engine — parses, validates, and executes incoming queries, orchestrating calls to resolvers.</li> <li>Data Sources Layer — the data providers</li> </ul> <p><span style="margin-left: 10px;"></span> Here’s how a typical query flow works:</p> <ol> <li>The client sends a JSON payload with a query or mutation to /graphql.</li> <li>The GraphQL server parses the query and validates it against the schema.</li> <li>The query engine executes each field’s resolver, often asynchronously.</li> <li>Data from various sources (SQL, REST APIs, caches) is merged into the requested shape.</li> <li>The server returns exactly the requested fields in JSON.</li> </ol> <p><span style="margin-left: 10px;"></span> Resolvers are small, composable units that describe how to fetch a specific piece of data. This makes GraphQL naturally extensible and federated — different services can own parts of the schema and resolve their respective data independently.</p> <p><span style="margin-left: 10px;"></span> Because of this architecture, GraphQL excels at aggregating data from multiple backend sources into a single queryable interface. It trades some server-side simplicity for client flexibility and performance. While REST structures the world by endpoints, GraphQL structures it by types and relationships.</p> <h3 id="strengths-and-weaknesses-2">Strengths and Weaknesses</h3> <table> <thead> <tr> <th><strong>Pros</strong></th> <th><strong>Cons</strong></th> </tr> </thead> <tbody> <tr> <td>Fetch exactly what you need (no over/under-fetching)</td> <td>Complexity in caching and monitoring</td> </tr> <tr> <td>Single endpoint simplifies API evolution</td> <td>Initial learning curve for schema &amp; resolver patterns</td> </tr> <tr> <td>Self-documenting schema (introspection)</td> <td>Potential N+1 problem in naive resolvers</td> </tr> <tr> <td>Excellent for frontend-driven development</td> <td>Overhead for simple CRUD use cases</td> </tr> <tr> <td>Strong tooling ecosystem (DGS and many others)</td> <td>Requires runtime execution layer, not just HTTP routing</td> </tr> </tbody> </table> <h3 id="the-n1-problem--and-the-dgs-solution">The N+1 Problem — and the DGS Solution</h3> <p><span style="margin-left: 10px;"></span> In my personal project, I initially ported a REST backend to GraphQL to reduce the multiple HTTP calls needed for the same thing in different views. The benefits were immediate — fewer endpoints, cleaner frontend queries, and faster perceived performance.</p> <p><span style="margin-left: 10px;"></span> But then I hit the N+1 query problem — where nested resolvers cause multiple database hits per entity. For example, fetching a list of breweries with their beers triggered one DB query per brewery.</p> <p><span style="margin-left: 10px;"></span> Thankfully, using Netflix DGS, I leveraged its DataLoader integration — a batching and caching mechanism that consolidates those queries into efficient bulk operations. It was a game changer, turning what could have been a performance regression into a well-optimized data flow.</p> <p><span style="margin-left: 10px;"></span> Netflix DGS (Domain Graph Service) is an open-source GraphQL framework built by Netflix and designed to simplify GraphQL server development in Java and Kotlin. It’s opinionated in a good way — integrating tightly with Spring Boot, enforcing schema-first development.</p> <p><span style="margin-left: 10px;"></span> The Netflix DGS framework implements this architecture within the Spring ecosystem. It follows a schema-first approach:</p> <ul> <li>You start by defining .graphqls schema files.</li> <li>Then implement @DgsQuery, @DgsMutation, and @DgsData components that act as resolvers.</li> <li>DGS automatically wires them into a GraphQL runtime, handling execution, validation, and DataLoader batching.</li> </ul> <p><span style="margin-left: 10px;"></span> Internally, DGS uses graphql-java as the core engine and adds Netflix’s tooling for:</p> <ul> <li>Schema Federation (composing multiple domain services into one unified graph).</li> <li>Instrumentation and metrics collection.</li> <li>Schema registry integration and validation pipelines.</li> <li>DataLoader integration to batch and cache nested queries efficiently.</li> </ul> <p><span style="margin-left: 10px;"></span> Unlike some other GraphQL implementations, DGS treats the GraphQL schema (.graphqls files) as the source of truth. From that schema, you implement data fetchers — the functions that resolve the data for each type or field.</p> <p><span style="margin-left: 10px;"></span> For example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Brewery {
  id: ID!
  name: String!
  beers: [Beer]
}

type Beer {
  id: ID!
  name: String!
  reviews: [Review]
}

type Query {
  brewery(id: ID!): Brewery
}
</code></pre></div></div> <p><span style="margin-left: 10px;"></span> What I really appreciate about DGS is how it enforces structure without removing flexibility. Resolvers are just annotated functions, so it fits neatly into Spring Boot’s dependency injection ecosystem. You also get built-in integration with DataLoader, which helps solve the N+1 query problem by batching and caching database calls.</p> <p><span style="margin-left: 10px;"></span> Another big plus is how well DGS plays with GraphQL Federation. In a larger setup, multiple teams can build their own GraphQL services (each describing a “domain”), and Netflix DGS provides tools to stitch these schemas together.</p> <h2 id="final-thoughts">Final Thoughts</h2> <p><span style="margin-left: 10px;"></span> SOAP, REST, and GraphQL are not direct competitors, but evolutionary stages in how we exchange data:</p> <ul> <li>SOAP gave us rigor — at the cost of agility.</li> <li>REST gave us simplicity — at the cost of precision.</li> <li>GraphQL gives us precision — at the cost of complexity.</li> </ul> <p><span style="margin-left: 10px;"></span> In my professional work, REST has been the backbone of countless microservices. It’s consistent, predictable, and incredibly well-understood across teams. The tooling is mature, the caching model is natural, and HTTP’s semantics fit like a glove. But REST also taught me its limits — especially in frontend-heavy applications where data rarely fits neatly into single resources. I’ve seen endpoints multiply, clients chained across several requests, and payloads balloon to cover every edge case.</p> <p><span style="margin-left: 10px;"></span> That pain is exactly what led me, in a personal project with a friend, to experiment with GraphQL. The immediate payoff was huge: fewer round trips, cleaner frontend code, and a noticeable reduction in friction between backend and UI.</p> <p><span style="margin-left: 10px;"></span> But the joy was brief. As our schema grew and queries became more nested, we ran headlong into the N+1 query problem — a classic GraphQL problem where resolvers trigger multiple database hits per record. Performance went down the drain. The problem wasn’t GraphQL itself; it was our implementation.</p> <p><span style="margin-left: 10px;"></span> That’s when we discovered Netflix DGS. DGS reframed GraphQL for us — not as an experimental tool, but as an enterprise-ready framework. Its schema-first approach gave structure where GraphQL alone offered freedom, and its DataLoader integration handled batching so elegantly that our N+1 nightmare disappeared almost overnight. Suddenly, GraphQL development felt disciplined again — type-safe, introspectable, and scalable.</p> <p><span style="margin-left: 10px;"></span> If SOAP is the tank, REST the reliable pickup truck, GraphQL is the modern EV — sleek and efficient, but requiring a bit more engineering under the hood to reach its potential.</p> <p><span style="margin-left: 10px;"></span> The lesson? Each has its place — the key is knowing when to drive which one.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Paulo Almeida. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>